---
slug: functional-programming-immutabilite
title: prog fonct en java - immutabilit√©
authors: [adelegue]
tags: [patterns, java, prog-fonctionnelle]
---

Dans le post pr√©c√©dent, on a vu les fondations de la programmation fonctionnelle. Ici, on va s'int√©resser un peu plus en d√©tail √† l'immutabilit√© en java.

{/* truncate */}

## L'instant musical

<iframe width="560" height="315" src="https://www.youtube.com/embed/-1X73VmCj98?si=NxxgJSzWA5PvX7Yv" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

## L'immutabilit√©

Une fa√ßon de ne pas gal√©rer avec les fonctions pures, c'est d'avoir des variables immuables. Mais comment √ßa se passe en java ?

Il existe le mot cl√© `final` qui permet d'assurer qu'une variable ne pourra pas √™tre r√©affect√©e.
Il peut √™tre utilis√© :
* Pour des variables :
```java
final String foo = "bar";
```
* Pour des attributs de classe :
```java
class Foo {
    final String bar;
}
```
* Pour des param√®tres de m√©thode :
```java
public String foo(final String bar) {
    ...
}
```
* Pour la d√©finition d'une classe pour s'assurer que la classe ne sera pas √©tendue
```java
final class Foo {
    ...
}
```

Avec des langages un peu plus r√©cents comme kotlin ou scala, ou l'immutabilit√© a √©t√© pris en compte d√®s le d√©part, on aura une syntaxe simplifi√©e avec les mots cl√©s `var` et `val` :

```kotlin
val fooImmutable = "Bar"
var fooMutable = "Bar"
```

### Les structures de donn√©es

Traditionnellement en java, on repr√©sente les structures de donn√©es par des `bean`.
Un bean d√©clare des attributs priv√©s mutables et on propose des getters et des setters pour respectivement acc√©der aux attributs et modifier les attributs.

```java
public class User {

    private String nom;
    private String email;

    public String getNom() {
        return nom;
    }

    public void setNom(String nom) {
        this.nom = nom;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }
}
```

En plus de la verbosit√©, ici, on est loins de l'immutabilit√© souhait√©e !

Une premi√®re approche serait de d√©clarer les attributs `final`, et tant qu'on y est, on va les d√©clarer `public`,
comme √ßa : pas besoin de `getter` !

```java
public class User {

    public final String nom;
    public final String email;

    public User(String nom, String email) {
        this.nom = nom;
        this.email = email;
    }
}
```

On peut encore faire plus concis, en rempla√ßant la classe par un record :

```java
public record User(String nom, String email) {}
```

Les attributs du record sont immuables par d√©faut.

Avoir des structures immuables ajoute une certaine s√©curit√© et diminue la charge mentale lors du d√©veloppement mais, elle vient avec un certain nombre de contraintes.

Premi√®rement, comme il n'y a plus de setter, il devient plus compliqu√© de modifier un attribut. Pour √ßa, on va devoir cr√©er une nouvelle instance :

```java
public record User(String nom, String email) {
    public User withNom(String nom) {
        return new User(nom, email);
    }
    public User withEmail(String email) {
        return new User(nom, email);
    }
}
```

Pour modifier l'email d'un user, il faudra passer par une nouvelle variable :

```java
var user = new User("Milo", "milo@gmail.com");
var userWithNameUpdated = user.withEmail("milo.aukerman@gmail.com");
```
Dans les futures versions de java, on devrait directement avoir le mot cl√© `with` :
```java
var user = new User("Milo", "milo@gmail.com");
var userWithNameUpdated = user with { email = "milo.aukerman@gmail.com" };
```
Malheureusement, il va falloir attendre un peu...

En attendant, il faudra √©crire les `with` √† la main ou utiliser la lib dont personne ne prononce le nom, qui commence par `lom` et qui finit par `bok`.

En utilisant des structures avec des attributs immuables, on peut vite se rendre compte que √ßa devient assez difficile de modifier la feuille d'une structure un peu plus compl√®xe :

```java
var userUpdated = user
        .withAddress(user.address
            .withCity(
                user.address.city.withZipCode("79000")
            )
        );
```

En programmation fonctionnelle, il existe ce qu'on appelle les optics pour modifier facilement des structures arborescentes (peut √™tre le sujet d'un article futur !).
Malheureusement, il n'existe aucune impl√©mentation en java.


## L'immutabilit√© dans le jdk

Nous venons de voir comment cr√©er nos propres structures immuables, mais que propose java en terme d'immutabilit√© dans le jdk ?

Historiquement, java n'√©tait pas trop port√© sur l'immutabilit√©, m√™me si les choses changent petit √† petit (comme on l'a vu avec les records).
Pourtant, certaines classes sont immuables par d√©faut, et depuis tr√®s longtemps, on peut penser √† `java.lang.String`.

√áa ne nous viendrait pas √† l'esprit d'√©crire ce code :

```java
String monTexte = "Un texte";
monTexte.append(" avec une suite");
```

Tout le monde a bien int√©gr√© que `String` est immuable et que la concatenation produira une nouvelle valeur :

```java
String monTexte = "Un texte";
String textComplet = monTexte + " avec une suite";
```

On est tr√®s loin de √ßa dans beaucoup de structures largement utilis√©es comme par ex : `java.util.List` et plus largement les collections.

### Les collections

La gestion de l'immutabilit√© dans l'API de collection n'est clairement pas au niveau.
Java propose des utilitaires pour v√©rrouiller des collections, mais pas vraiment d'outils pour pouvoir les modifier.

Il existe par exemple `Collections.unmodifiableList` :

```java
ArrayList<String> list = new ArrayList<>();
list.add("a");
List<String> immutableList = Collections.unmodifiableList(list);
immutableList.add("b");
```

Ici, on va obtenir üí•üß®üí£
```
java.lang.UnsupportedOperationException
	at java.base/java.util.Collections$UnmodifiableCollection.add(Collections.java:1091)
```

<img src="https://ichef.bbci.co.uk/ace/ws/640/cpsprodpb/AAEC/production/_97665734_mediaitem97650019.jpg.webp" width={500}/>

D'ailleurs, dans certains cas, ce sont directement des listes immuables qui sont cr√©√©es :

```java
List<String> immutableList = List.of("a");
immutableList.add("b");
```

M√™me r√©sultat üí•üß®üí£

```
java.lang.UnsupportedOperationException
	at java.base/java.util.Collections$UnmodifiableCollection.add(Collections.java:1091)
```

Perso, je trouve ce comportement assez angoissant, on ne sait jamais quand la manipulation d'une liste va nous p√©ter √† la gueule‚Ä¶

Dans le paragraphe pr√©c√©dent, quand on voulait modifier une structure, il fallait cr√©er une nouvelle instance avec la valeur modifi√©e.
Est-ce qu'on ne pourrait pas faire de m√™me avec les listes ?

Et bien la solution, c'est d'utiliser la syntaxe suivante :

```java
List<String> immutableList = List.of("a");
List<String> newList = Stream
    .concat(
        immutableList.stream(),
        Stream.of("b")
    )
    .toList();
```

√áa fonctionne, mais √ßa reste assez verbeux.

Une autre option :
```java
List<String> immutableList = List.of("a");
List<String> tempList = new ArrayList<>(immutableList);
tempList.add("b");
List<String> newList = Collections.unmodifiableList(tempList);
```

Pas vraiment mieux...


Quand on commence √† vraiment utiliser des collections immuables, l'API de collections de la lib [`vavr`](https://vavr.io/) est largement au-dessus du jdk.

Vavr a port√© toute l'API de collection de scala en java, et les collections propos√©es sont immuables par d√©faut :

```java
List<String> empty = List.empty();
List<String> unElement = empty.append("a");
List<String> deuxElements = unElement.append("b");
```
Ici, pas de mauvaises surprises ! Comme par exemple, des exceptions qui nous p√®tent √† la gueule.

### Impacts de l'immutabilit√©

Comme pour les structures immuables, l'immutabilit√© dans les collections vient avec son lot de manipulations un peu tricky.

Un cas d'√©cole, incr√©menter un compteur en parcourant une liste :

```java
int i = 0;
for (String elt : list) {
    i = i + elt.length();
}
```

N'est plus possible en version immuable. Le code suivant ne compile plus :

```java
final int i = 0;
for (String elt : list) {
    i = i + elt.length();
}
```

Il faudra √©crire en java standard :

```java
Integer res = list.stream()
    .reduce(0, (acc, elt) ->  acc + elt.length(), Integer::sum);
```

Ou cette version avec vavr (pas besoin de g√©rer le cas de la parall√©lisation comme avec java std) :

```java
Integer res = list.foldLeft(0, (acc, elt) ->  acc + elt.length());
```

Sur plein d'aspect, l'API de collections de vavr permettra de g√©rer plus simplement tout un tas d'op√©rations.
Elle vient avec plein de m√©thodes out of box, contrairement au jdk :
* `find`, `distinct`, `distinctBy`, `groupBy` `max`, `count` ...

Les gatherer ont √©t√© introduits, dans la derni√®re version de java, √ßa rendra peut-√™tre l'utilisation native des collections plus utilisable.

## La r√©cursivit√©

L'immutabilit√© peut aussi amener l'usage de la r√©cursivit√©, qui au passage n'est pas tr√®s optimis√© en java : attention aux `StackOverflowError` !

On va prendre un exemple avec un use case : une structure arborescente pour laquelle on souhaiterait compte le nombre de n≈ìuds.

Ex :

```java
record Node(String id, Node child) {}
```

En java classique, on √©crirait :

```java
static Integer count(Node node) {
    Node tmp = node;
    int count = 0;
    while (tmp != null) {
        count++;
        tmp = tmp.child;
    }
    return count;
}
```
Si on veut se passer de mutabilit√©, il va falloir utiliser la r√©cursivit√© :

```java
static Integer count(Node node) {
    if (node == null) return 0;

    return 1 + count(node.child);
}
```

## Conclusion

Il existe des outils dans le jdk pour g√©rer l'immutabilit√© mais, malheureusement, comme souvent avec java,
m√™me si les fondations sont l√†, on sera vite tent√© d'ajouter des d√©pendances pour profiter d'API plus fluides.

Manipuler en permanences des objets immuables aura un co√ªt d'apprentissage et il faudra probablement faire preuve d'ing√©niosit√© pour r√©soudre certaines situations.

Une fois le coup de main pris, manipuler des objets immuables lib√®re un peu la t√™te, pas de mauvaises surprises,
pas de risques que l'objet ait √©t√© modifi√© hors du scope de la m√©thode courante.
